--- drivers/video/tegra/dc/edid.c
+++ drivers/video/tegra/dc/edid.c
@@ -15,7 +15,6 @@
  *
  */
 
-#define DEBUG
 
 #include <linux/debugfs.h>
 #include <linux/fb.h>
@@ -33,6 +32,7 @@
 	u8			*data;
 	unsigned		len;
 	u8			support_stereo;
+	struct tegra_edid_hdmi_eld		eld;
 };
 
 #if defined(DEBUG) || defined(CONFIG_DEBUG_FS)
@@ -169,7 +169,25 @@
 	u8 tmp;
 	u8 code;
 	int len;
-
+	int i;
+	bool basic_audio = false;
+
+	ptr = &raw[0];
+
+	/* If CEA 861 block get info for eld struct */
+	if (edid && ptr) {
+		if (*ptr <= 3)
+			edid->eld.eld_ver = 0x02;
+		edid->eld.cea_edid_ver = ptr[1];
+
+		/* check for basic audio support in CEA 861 block */
+		if(raw[3] & (1<<6)) {
+			/* For basic audio, set spk_alloc to Left+Right.
+			 * If there is a Speaker Alloc block this will
+			 * get over written with that value */
+			basic_audio = true;
+		}
+	}
 	ptr = &raw[4];
 
 	while (ptr < &raw[idx]) {
@@ -182,13 +200,33 @@
 		 * tag code 2: video data block
 		 * tag code 3: vendor specific data block
 		 */
-		code = (tmp >> 5) & 0x3;
+		code = (tmp >> 5) & 0x7;
 		switch (code) {
+		case 1:
+		{
+			edid->eld.sad_count = len;
+			edid->eld.conn_type = 0x00;
+			edid->eld.support_hdcp = 0x00;
+			for (i = 0; (i < len) && (i < ELD_MAX_SAD); i++)
+				edid->eld.sad[i] = ptr[i + 1];
+			len++;
+			ptr += len; /* adding the header */
+			/* Got an audio data block so enable audio */
+			if(basic_audio == true)
+				edid->eld.spk_alloc = 1;
+			break;
+		}
 		/* case 2 is commented out for now */
 		case 3:
 		{
 			int j = 0;
 
+			if ((ptr[1] == 0x03) &&
+				(ptr[2] == 0x0c) &&
+				(ptr[3] == 0)) {
+				edid->eld.port_id[0] = ptr[4];
+				edid->eld.port_id[1] = ptr[5];
+			}
 			if ((len >= 8) &&
 				(ptr[1] == 0x03) &&
 				(ptr[2] == 0x0c) &&
@@ -208,7 +246,28 @@
 						edid->support_stereo = 1;
 				}
 			}
+			if ((len > 5) &&
+				(ptr[1] == 0x03) &&
+				(ptr[2] == 0x0c) &&
+				(ptr[3] == 0)) {
+
+				edid->eld.support_ai = (ptr[6] & 0x80);
+			}
 
+			if ((len > 9) &&
+				(ptr[1] == 0x03) &&
+				(ptr[2] == 0x0c) &&
+				(ptr[3] == 0)) {
+
+				edid->eld.aud_synch_delay = ptr[10];
+			}
+			len++;
+			ptr += len; /* adding the header */
+			break;
+		}
+		case 4:
+		{
+			edid->eld.spk_alloc = ptr[1];
 			len++;
 			ptr += len; /* adding the header */
 			break;
@@ -251,9 +310,16 @@
 		return ret;
 
 	memset(specs, 0x0, sizeof(struct fb_monspecs));
+	memset(&edid->eld, 0x0, sizeof(struct tegra_edid_hdmi_eld));
 	fb_edid_to_monspecs(edid->data, specs);
 	if (specs->modedb == NULL)
 		return -EINVAL;
+	memcpy(edid->eld.monitor_name, specs->monitor, sizeof(specs->monitor));
+	edid->eld.mnl = strlen(edid->eld.monitor_name) + 1;
+	edid->eld.product_id[0] = edid->data[0x8];
+	edid->eld.product_id[1] = edid->data[0x9];
+	edid->eld.manufacture_id[0] = edid->data[0xA];
+	edid->eld.manufacture_id[1] = edid->data[0xB];
 
 	extension_blocks = edid->data[0x7e];
 
@@ -282,6 +348,16 @@
 	edid->len = i * 128;
 
 	tegra_edid_dump(edid);
+	return 0;
+}
+
+int tegra_edid_get_eld(struct tegra_edid *edid,
+			struct tegra_edid_hdmi_eld *elddata)
+{
+	if (!elddata)
+		return -EFAULT;
+
+	memcpy(elddata, &edid->eld, sizeof(struct tegra_edid_hdmi_eld));
 
 	return 0;
 }
@@ -366,3 +442,4 @@
 
 module_init(tegra_edid_init);
 module_exit(tegra_edid_exit);
+
