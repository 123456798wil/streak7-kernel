--- drivers/video/tegra/dc/hdmi.c
+++ drivers/video/tegra/dc/hdmi.c
@@ -46,11 +46,25 @@
 
 #define HDMI_REKEY_DEFAULT		56
 
+#define HDMI_ELD_RESERVED1_INDEX               1
+#define HDMI_ELD_RESERVED2_INDEX               3
+#define HDMI_ELD_VER_INDEX                     0
+#define HDMI_ELD_BASELINE_LEN_INDEX            2
+#define HDMI_ELD_CEA_VER_MNL_INDEX             4
+#define HDMI_ELD_SAD_CNT_CON_TYP_SAI_HDCP_INDEX                5
+#define HDMI_ELD_AUD_SYNC_DELAY_INDEX  6
+#define HDMI_ELD_SPK_ALLOC_INDEX               7
+#define HDMI_ELD_PORT_ID_INDEX         8
+#define HDMI_ELD_MANF_NAME_INDEX               16
+#define HDMI_ELD_PRODUCT_CODE_INDEX            18
+#define HDMI_ELD_MONITOR_NAME_INDEX            20
+
 int hdmi_resolution;
 
 struct tegra_dc_hdmi_data {
 	struct tegra_dc			*dc;
 	struct tegra_edid		*edid;
+        struct tegra_edid_hdmi_eld              eld;
 	struct tegra_nvhdcp		*nvhdcp;
 	struct delayed_work		work;
 
@@ -68,6 +82,7 @@
 	bool				hpd_pending;
 
 	bool				dvi;
+        bool                            eld_retrieved;
 };
 
 const struct fb_videomode tegra_dc_hdmi_supported_modes[] = {
@@ -496,12 +511,21 @@
 {
 	int clock_per_frame = tegra_dc_calc_clock_per_frame(mode1);
 
+        if (!clock_per_frame)
+                return false;
+
 	/* allows up to 1Hz of pixclock difference */
-	return mode1->xres	== mode2->xres &&
-		mode1->yres	== mode2->yres &&
-	/*	(abs(PICOS2KHZ(mode1->pixclock - mode2->pixclock)) *
-		1000 / clock_per_frame <= 1) && */
-		mode1->vmode	== mode2->vmode;
+	if (mode1->pixclock != mode2->pixclock) {
+                return (mode1->xres == mode2->xres &&
+                mode1->yres == mode2->yres &&
+                (abs(PICOS2KHZ(mode1->pixclock - mode2->pixclock)) * 1000
+                / clock_per_frame <= 1) &&
+                mode1->vmode == mode2->vmode);
+        } else {
+                return (mode1->xres == mode2->xres &&
+                mode1->yres == mode2->yres &&
+                mode1->vmode == mode2->vmode);
+        }
 }
 
 static bool tegra_dc_hdmi_valid_pixclock(const struct tegra_dc *dc,
@@ -566,6 +590,12 @@
 		goto fail;
 	}
 
+        err = tegra_edid_get_eld(hdmi->edid, &hdmi->eld);
+        if (err < 0) {
+                dev_err(&dc->ndev->dev, "error populating eld\n");
+                goto fail;
+        }
+        hdmi->eld_retrieved = true;
 	/* monitors like to lie about these but they are still useful for
 	 * detecting aspect ratios
 	 */
@@ -577,11 +607,16 @@
 
 	tegra_fb_update_monspecs(dc->fb, &specs, tegra_dc_hdmi_mode_filter);
 	hdmi->hpd_switch.state = 0;
-	switch_set_state(&hdmi->hpd_switch, 1);
+	if (hdmi->eld.spk_alloc)
+                switch_set_state(&hdmi->hpd_switch, 1);
+        else
+                switch_set_state(&hdmi->hpd_switch, 2);
+
 	dev_info(&dc->ndev->dev, "display detected\n");
 	return true;
 
 fail:
+        hdmi->hpd_switch.state = 1; 
 	switch_set_state(&hdmi->hpd_switch, 0);
 	tegra_nvhdcp_set_plug(hdmi->nvhdcp, 0);
 	return false;
@@ -649,6 +684,9 @@
 			queue_delayed_work(system_nrt_wq, &hdmi->work,
 					   msecs_to_jiffies(30));
 		hdmi->hpd_pending = false;
+        } else if (tegra_dc_hdmi_hpd(dc)) { /* Check for HDMI Peripheral */
+                queue_delayed_work(system_nrt_wq, &hdmi->work,
+                                           msecs_to_jiffies(100));
 	}
 	spin_unlock_irqrestore(&hdmi->suspend_lock, flags);
 	tegra_nvhdcp_resume(hdmi->nvhdcp);
@@ -746,6 +784,7 @@
 	hdmi->disp2_clk = disp2_clk;
 	hdmi->suspended = false;
 	hdmi->hpd_pending = false;
+        hdmi->eld_retrieved = false;
 	spin_lock_init(&hdmi->suspend_lock);
 
 	hdmi->hpd_switch.name = "hdmi";
